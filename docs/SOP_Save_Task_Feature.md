### "我的任务"功能标准作业流程 (SOP) - V1.0

**版本: 1.0**
**创建日期: 2024-05-22**
**最后更新: 2024-08-22**
**当前实现状态: 核心功能已实现，部分高级功能待完善**

#### 1. 核心目标与设计哲学

本文档旨在明确并固化"保存结果到账户"（后续统一命名为"我的任务"）功能的设计方案与执行标准。

**核心原则：**
*   **简洁直观**: 功能流程应尽可能简单，符合用户直觉，降低学习成本。
*   **小步快跑**: 采用分阶段迭代的开发模式。第一阶段（V1.0）专注于实现核心的保存与加载功能，确保用户可以保存和恢复其工作成果。
*   **可扩展性**: 在技术实现上，应保证UI组件的可复用性和未来功能扩展的便利性，例如从弹框模式平滑过渡到独立页面模式。
*   **数据安全**: 在加载历史任务时，必须有明确的提示机制，防止用户意外丢失当前未保存的工作。

---

#### 2. 功能命名与入口

*   **统一名称**: 此功能统一命名为 **"我的任务"**。
*   **功能入口**:
    1.  **保存入口**: 主界面结果表格下方的 **"保存结果到账户"** 按钮。
    2.  **查看入口**: 页面顶部用户头像下拉菜单中的 **"我的任务"** 按钮。

---

#### 3. 核心工作流程

##### 3.1 保存与更新流程

1.  **首次保存 (另存为)** ✅ **已实现**:
    *   用户点击 **"保存结果到账户"** 按钮。
    *   系统弹出一个静态对话框（Modal）。对话框中的"任务名称"输入框会**自动预填**当前在结果表上方显示的、由智能分析生成或用户手动修改后的任务名称。
    *   用户可以**确认或修改**此名称后点击"确认"进行保存。
    *   系统向后端发送保存请求，成功后前端弹出全局提示（Toast）："任务保存成功"。
    *   若用户输入的任务名称已存在，系统应提示"名称已存在，请重新输入"。
    *   **实现细节**: 使用 `ensureSaveTaskModal()` 动态创建模态框，`performSaveTaskWithName()` 处理保存逻辑，错误信息在输入框下方内联显示。

2.  **加载后更新 (Overwrite)** ❌ **未实现**:
    *   当用户从"我的任务"列表中加载了一个已有任务后，主界面的 **"保存结果到账户"** 按钮的文本和功能将自动切换为 **"更新任务"**。
    *   用户在对加载出的数据进行修改后，点击 **"更新任务"** 按钮。
    *   系统**不会**弹出命名框，而是直接使用当前任务的ID或名称，向后端发送更新请求，**覆盖**该任务之前的数据。
    *   更新成功后，前端弹出全局提示："任务更新成功"。
    *   **技术债务**: 需要实现 `currentLoadedTask` 状态管理，按钮文本动态切换，以及 `PUT /tasks/<id>` 接口调用。

##### 3.2 查看与加载流程

1.  **打开列表** ✅ **已实现**:
    *   用户点击顶部用户菜单中的 **"我的任务"**。
    *   系统以静态对话框（Modal）的形式，展示用户的任务列表。
    *   该列表应支持**翻页**功能，以应对未来任务数量增多的情况。
    *   列表中应至少展示 `任务名称` 和 `保存/更新时间`，并按时间倒序排列。
    *   列表中每条任务应有加载、删除按钮。
    *   **实现细节**: 使用 `ensureMyTasksModal()` 动态创建模态框，`fetchAndRenderMyTasks()` 处理分页逻辑，支持每页10条记录，智能禁用分页按钮。

2.  **加载任务** ✅ **已实现**:
    *   用户在任务列表中点击某一项任务的"加载"按钮。
    *   **冲突检查**: 系统首先检查当前主页面是否存在未保存的修改（例如，用户在输入框输入了新地址但未执行地理编码）。
    *   **冲突处理**:
        *   **如果**存在未保存的修改，系统弹窗提醒用户：**"当前有未保存的更改，加载新任务将覆盖现有内容，是否继续？"** 用户确认后才继续加载。
        *   **如果**不存在未保存的修改，则直接执行加载。
    *   **数据填充**: 系统从后端获取该任务的数据，并填充到主页面对应的模块中（详见第4节）。
    *   **实现细节**: 使用 `loadTaskById()` 函数，调用 `GET /tasks/<id>` 接口，通过 `confirm()` 进行冲突检查，成功后更新 `state.currentResults` 并刷新UI。

3.  **删除任务** ✅ **已实现**:
    *   用户在任务列表中点击某一项任务的"删除"按钮。
    *   系统弹出确认对话框："确定删除该任务吗？此操作不可撤销。"
    *   用户确认后，系统调用 `DELETE /tasks/<id>` 接口删除任务。
    *   删除成功后刷新任务列表并显示提示："任务已删除"。

---

#### 4. 数据模型 (第一阶段) ✅ **已实现**

在功能的第一个版本中，当用户保存任务时，后端数据库中应至少存储以下信息：

*   **`task_id`**: 任务的唯一标识符。
*   **`user_id`**: 关联的用户ID。
*   **`task_name`**: 用户输入的任务名称（字符串）。
*   **`result_data`**: 完整的地理编码结果表格数据。强烈建议存储为 **JSON** 格式，以保持数据结构的灵活性。
*   **`created_at` / `updated_at`**: 任务创建和最后更新的时间戳。

**加载逻辑** ✅ **已实现**:
*   加载时，`result_data` 的内容被完整地渲染到主页面的结果表格中。
*   当用户点击结果表格中的任意一行时，该行的地址等核心信息，应能自动填充到"逐条校准"区域对应的输入框中，以供用户查看或微调。

---

#### 5. 技术实现细节

##### 5.1 前端架构
*   **模态框管理**: 使用动态HTML注入方式创建模态框，避免在模板中预定义大量模态框HTML。
*   **状态管理**: 通过 `state.currentResults` 管理当前结果数据，`__myTasksPage` 管理分页状态。
*   **事件绑定**: 使用 `replaceWith()` 避免重复绑定事件监听器，通过 `window.__saveBtnBound` 标记防止委托重复触发。

##### 5.2 后端接口
*   **POST /tasks/**: 创建新任务，支持任务名称唯一性校验。
*   **GET /tasks/**: 获取任务列表，支持分页参数 `page` 和 `per_page`。
*   **GET /tasks/<id>**: 获取单个任务详情。
*   **PUT /tasks/<id>**: 更新任务（待实现）。
*   **DELETE /tasks/<id>**: 删除任务。

##### 5.3 错误处理
*   **网络错误**: 使用 try-catch 包装异步操作，显示友好的错误提示。
*   **业务错误**: 409状态码表示任务名称重复，在输入框下方显示内联错误信息。
*   **权限错误**: 401状态码表示未登录或登录过期，自动弹出登录模态框。

---

#### 6. 待完善功能

1.  **任务更新机制**: 实现加载任务后的"更新任务"按钮切换和覆盖保存逻辑。
2.  **任务名称编辑**: 在任务列表中支持直接编辑任务名称。
3.  **任务搜索**: 支持按任务名称搜索任务。
4.  **任务分类**: 支持任务标签和分类管理。
5.  **批量操作**: 支持批量删除、批量导出等操作。

---

#### 7. 已知问题与限制

1.  **分页边界**: 当前分页逻辑在边界情况下可能显示空白页，已通过自动回退机制缓解。
2.  **状态同步**: 任务加载后，如果用户手动修改数据，系统无法自动检测变更状态。
3.  **内存管理**: 大量任务数据可能影响前端性能，建议实现虚拟滚动或懒加载。

---

#### 8. 测试用例

1.  **保存任务**: 验证任务名称预填、重复名称检测、保存成功提示。
2.  **查看任务**: 验证任务列表加载、分页功能、空列表处理。
3.  **加载任务**: 验证冲突检测、数据填充、UI状态更新。
4.  **删除任务**: 验证确认对话框、删除成功、列表刷新。
5.  **错误处理**: 验证网络异常、权限错误、业务错误的友好提示。 