# 项目架构指南

**版本: 1.1**
**最后更新: 2023-10-28**

## 1. 引言

本文档为本项目定义了顶层的架构原则与代码组织规范。其目的在于确保所有当前及未来的开发工作，都能遵循清晰、一致的"关注点分离"原则，从而使代码库易于维护、易于扩展、易于理解。

所有修改代码的开发者及AI助手，都**必须**严格遵守此指南。

## 2. 核心架构原则：三层模型

本项目的后端架构基于一个标准的三层模型：**路由层 (负责编排)**、**服务层 (负责交互)** 和 **工具层 (负责计算)**。每一层都拥有独特且不重叠的职责。这种分离确保了业务逻辑、外部交互和纯粹算法的解耦。

*   **路由层 (`app/routes/`)**: 负责处理外部HTTP请求，编排业务流程。
*   **服务层 (`app/services/`)**: 负责与所有第三方API或外部服务（如数据库）进行直接交互。
*   **工具层 (`app/utils/`)**: 负责提供纯粹的、无状态的计算和数据处理函数。

---

## 3. 各层定义与职责

### 3.1. 路由与编排层 (`app/routes/`)

**职责**: 这一层是应用的入口，负责接收来自前端的HTTP请求，并返回最终的HTTP响应。它是业务流程的**"编排者"**。

*   **功能**:
    *   定义API接口 (Endpoints)，如 `/geocode/process`, `/user/login` 等。
    *   解析和验证请求参数（如JSON body, URL参数）。
    *   调用`services`层或`utils`层的函数来执行核心业务逻辑。
    *   组织和格式化从服务层返回的数据，将其构造成前端需要的JSON格式或渲染成HTML页面。
    *   处理用户会话 (Session)、认证与授权。
*   **原则**:
    *   **保持"轻量"**: 路由函数本身不应包含复杂的业务逻辑。其主要工作是参数校验和调用下游服务。
    *   **逻辑复用**: 不同的路由如果需要执行相似的逻辑，应将该逻辑提取到`utils`或`services`层。例如，`/jionlp_autocomplete` 和 `/geocode/process` 都依赖于地址补全，该逻辑被统一提取到了 `utils.address_processing` 模块中。

*   **禁止事项**:
    *   **禁止直接进行外部I/O操作**: 此层严禁包含任何 `aiohttp`, `requests` 或直接的数据库连接代码。所有外部交互都必须通过服务层进行。
    *   **禁止解析原始API响应**: 此层不应知道任何第三方API返回的JSON的具体结构。它只处理由服务层标准化后的数据对象。
    *   **禁止包含复杂的、可复用的算法**: 核心算法应属于工具层。

*   **实现范例: `app/routes/geocoding.py`**
    *   该文件完美诠释了路由层的职责。它定义了 `/geocode/process` 端点。
    *   它严格遵循 `docs/SOP_Multi_Source_Geocoding.md` 中定义的**瀑布流逻辑**，依次调用 `amap`, `tianditu`, `baidu` 等地理编码服务。
    *   它调用 `address_processing` 工具来计算置信度，并最终选择优胜者。

### 3.2. 服务与交互层 (`app/services/`)

此层扮演着我们的应用与所有外部世界（第三方API、数据库等）之间的"适配器"或"网关"。

*   **核心职责**:
    1.  封装与某个特定第三方服务的所有直接交互。
    2.  管理API密钥、认证、请求速率限制等。
    3.  构建对外部服务（如HTTP API）的请求。
    4.  执行该请求并获取原始返回数据。
    5.  解析原始数据，并将其**标准化**成我们应用内部易于理解的、统一的数据对象。

*   **禁止事项**:
    *   **禁止包含跨服务的业务逻辑**: 一个服务（如 `AmapGeocoder`）不应知道任何关于另一个服务（如 `BaiduGeocoder`）的信息。瀑布流、比较和决策逻辑完全属于路由层。
    *   **禁止关心上层业务流程**: 服务层只负责完成自己的任务（如"给我这个地址的坐标"），而不关心这个任务是整体流程中的第几步。

*   **实现范例: `app/services/geocoding_apis.py`**
    *   每一个 `Geocoder` 类都是一个独立的服务处理器。
    *   `AmapGeocoder` 负责向高德地图发起HTTP调用，解析其独特的JSON响应，并将其标准化为我们内部统一的地理编码结果格式。
    *   它还实现了SOP中定义的服务商内部逻辑，例如高德API返回多个候选者时的内部选优。

### 3.3. 工具与计算层 (`app/utils/`)

**职责**: 提供可在整个应用范围内复用的、与具体业务场景无直接耦合的通用函数和核心算法。

*   **功能**:
    *   **核心算法**: 包含项目中最核心的、可独立测试的算法。例如 `address_processing.py` 中的统一置信度计算模型 (`calculate_unified_confidence`) 和 **全局统一的地址补全逻辑** (`complete_address_jionlp`)。
    *   **数据转换**: 如 `geo_transforms.py` 中不同坐标系（WGS84, GCJ02）之间的转换。
    *   **第三方库封装**: 封装对某些基础库的调用，提供更简洁的接口。
    *   **通用帮助函数**: 如自定义的装饰器、API密钥管理器等。
*   **原则**:
    *   **无状态**: 工具函数应该是无状态的，即它们的输出仅依赖于输入参数，不依赖于任何外部或全局状态。

*   **禁止事项**:
    *   **禁止包含任何外部状态或I/O**: 此层中的函数应当是"纯函数"。它们不应知道数据库、HTTP请求、API密钥或应用配置的存在。它们接收数据作为输入，处理数据，然后返回结果，其行为是完全确定性的。

*   **实现范例: `app/utils/address_processing.py`**
    *   该文件包含 `calculate_unified_confidence` 等函数，它们是实现我们SOP中定义的统一置信度模型的纯计算逻辑。

---

## 4. 模块化实现范例：多源地理编码数据流

以下数据流展示了上述三层架构原则如何应用于"多源地理编码"这一具体业务场景。

1.  **[路由层]** `geocoding.py` 的 `/process` 端点收到一个包含地址的请求。
2.  **[路由层]** 调用 **工具层** `address_processing.py` 中的函数执行地址补全和初步解析 (SOP 步骤一)。
3.  **[路由层]** 启动瀑布流，调用 **服务层** `geocoding_apis.py` 中的 `AmapGeocoder.geocode()`。
4.  **[服务层]** `AmapGeocoder` 向高德发起HTTP调用，并获取原始JSON响应。
5.  **[服务层]** `AmapGeocoder` 内部调用 **工具层** 的 `calculate_unified_confidence` 来完成SOP中定义的"内部选优"。
6.  **[服务层]** `AmapGeocoder` 将最佳候选者标准化为内部格式，并返回给 **路由层**。
7.  **[路由层]** 检查结果的置信度。如果太低，则继续调用 **服务层** 的 `TiandituGeocoder.geocode()`。
8.  **[服务层]** `TiandituGeocoder` 发起HTTP调用，获取原始响应，并将其标准化（包含原生分数）。
9.  **[路由层]** 收到标准化的结果，并调用 **工具层** 的 `calculate_confidence_B` 来计算其置信度。
10. **[路由层]** 持续此流程，直到选出"优胜者"。
11. **[路由层]** 如果SOP要求，调用优胜者对应的 **服务层** `Geocoder` 类中的 `reverse_geocode` 方法进行结果增强。
12. **[路由层]** 将最终增强后的结果格式化为JSON并发送响应。 