### 地址输入面板功能规格书 (SOP)

**版本: 1.2 (根据2024-05代码实现更新)**
**最后更新日期: 2023-10-28**

#### 1. 核心目标

本文档旨在详细说明"地址输入面板"区域内，所有提供给用户的地址预处理和数据清洗功能。与线性的"多源地理编码SOP"不同，本文档将这些功能视为一个"工具箱"，逐一阐明其用途、触发方式和技术实现，以确保功能逻辑的清晰性和未来维护的一致性。

---

#### 2. 功能模块一：自动化基础清洗

*   **功能目标**: 解决用户从外部（如Excel、网页）复制地址时，常常会带入多余的序号、空格、制表符和空行等"脏数据"的问题。此功能旨在将输入的原始文本，快速规范化为干净的、每行一个地址的标准格式。

*   **界面元素**:
    *   地址输入文本域 (`textarea#addresses`)。

*   **执行流程：三层触发机制**
    *   **第一层 (便利性触发): 粘贴时 (`on paste`)**
        *   **目的**: 解决最大宗的脏数据来源，提供即时、流畅的粘贴体验。
        *   **行为**: 用户在文本域中执行粘贴操作时，立即无条件触发一次清洗。
    *   **第二层 (即时反馈): 编辑后失焦时 (`on blur` after `on input`)**
        *   **目的**: 处理用户手动编辑后产生的脏数据，并及时提供视觉反馈。
        *   **行为**: 系统会通过 `input` 事件监测文本域内容是否发生过变化。仅当内容变化后，用户将焦点从文本域移开时 (`blur` 事件)，才会触发一次清洗，以避免不必要的操作。
    *   **第三层 (最终保障): 点击编码按钮时**
        *   **目的**: 作为绝对的"守门员"，确保发送到后端进行处理的数据是100%干净的，防止任何边缘情况。
        *   **行为**: 当用户点击"开始地理编码"或"智能编码"按钮时，系统会在执行任何其他逻辑（如地址补全、API调用）之前，强制对文本域中的所有内容再执行一次最终的清洗。
*   **核心逻辑 (所有触发共享)**:
    *   **V2.1 清洗流程升级**: 清洗逻辑已经升级为一个严谨的多阶段管道，确保了对各种脏数据的兼容性和处理的精确性。完整流程如下：
    1.  **换行符标准化**: 首先，使用 `/\r?\n|\r/` 正则表达式对输入文本进行分割。这确保了无论文本来自 Windows (`\r\n`) 还是 Unix/macOS (`\n`)，都能被正确地拆分为独立的行，从根源上避免了因换行符不一致导致的空行问题。
    2.  **行级处理 (循环)**: 对每一行执行以下操作：
        *   **移除列表标记**: 应用 `^\s*([【（(\[#*•-]|\d+[.)、．\]】])\s*` 正则表达式，移除行首的各种列表标记（如 `1.`、`* ` 等）。此规则经过精心设计，能避免误伤正常的、以括号或特殊字符开头的地址名称(如 `(A-1)栋`)。
        *   **内部空格标准化**: 将地址内部的全角空格（`　`）转换为半角空格，并将多个连续的空格或制表符合并为一个单一空格。这个重要的改进取代了过去粗暴移除所有空格的策略，旨在保留地址中必要的间隔（如 `A 栋`），同时清理多余的空白。
        *   **过滤垃圾行**: 识别并清除那些在处理后只剩下无关符号、纯数字或无意义内容的行。
    3.  **最终过滤**: 移除所有在上述流程中变为空的行，并用标准的换行符 (`\n`) 将干净的地址重新组合成最终的文本。

*   **技术实现**:
    *   核心前端逻辑由 `static/js/modules/address-cleaner.js` 中的 `cleanAddresses` 函数实现，该函数内置了最新的通用正则表达式。
    *   **触发器实现**:
        *   `paste` 和 `blur` 事件的监听定义在 `static/js/modules/address-cleaner.js` 中。
        *   "最终保障"的调用逻辑则位于 `static/js/geocoding.js` 中两个编码按钮的点击事件处理函数内。

*   **开发准则：单一功能，单一实现 (Single Functionality, Single Implementation)**
    *   **问题根源**: 历史代码中曾存在两套清洗逻辑：一个用于手动按钮，一个用于粘贴事件，导致了功能不一致和代码冗余。

---

#### 3. 功能模块二：自动分行

*   **功能目标**: 方便用户处理从某些系统导出的、将多个地址用特定分隔符（如逗号、分号）拼接在同一行的数据。此功能可以将这样的单行数据，快速拆分为标准的多行地址格式。

*   **界面元素**:
    *   "自动分行"按钮 (`button#autoSplitBtn`)。
    *   分隔符输入框 (`input#splitDelimiters`)，允许用户自定义分隔符。

*   **执行流程**:
    1.  用户在地址输入框中粘贴包含分隔符的文本。
    2.  用户可以（可选）在分隔符输入框中修改用于拆分的字符。
    3.  用户点击"自动分行"按钮。
    4.  系统读取分隔符，并使用正则表达式将文本域中的内容进行全局拆分。
    5.  拆分后的每个部分经过`trim`（去除首尾空格）处理，然后重新组合成多行，写回地址输入框。

*   **技术实现**:
    *   该功能完全在前端实现，不涉及后端调用。
    *   核心逻辑由 `static/js/modules/address-input.js` 中的 `autoSplitAddresses` 函数实现。

---

#### 4. 功能模块三：行政区划补全

*   **功能目标**: 解决用户地址信息中普遍存在的省、市、区信息缺失问题。通过调用强大的`jionlp`库，自动识别并补全这些缺失的行政区划信息，从而极大地提升后续地理编码的准确率。

*   **界面元素**:
    *   "自动补全行政区划"按钮 (`button#autoCompleteBtn`)。

*   **执行流程**:
    1.  **用户手动触发**: 用户点击"自动补全行政区划"按钮。
    2.  **内置自动触发**: 在用户点击"开始地理编码"或"智能编码"按钮后，该功能会作为核心流程的第一步被强制自动执行。
    3.  **前端逻辑**:
        *   `static/js/modules/address-input.js` 中的 `autoCompleteAddresses` 函数被调用。
        *   它收集当前文本域中的所有地址，并通过`fetch`向后端API `/jionlp_autocomplete` 发起一个POST请求。
    4.  **后端逻辑**:
        *   位于 `app/routes/main.py` 的 `/jionlp_autocomplete` 接口接收到请求。
        *   该接口循环遍历地址列表，并为每个地址调用位于 `app/utils/address_processing.py` 中的核心工具函数 `complete_address_jionlp`。
        *   `complete_address_jionlp` 函数是所有补全逻辑的唯一源头，它负责执行真正的`jionlp.parse_location`和地址拼接工作。
    5.  **返回与更新**: 后端将补全后的地址列表返回给前端，前端将其写回地址输入框。

*   **架构核心原则**:
    *   **两用一源**: 该功能体现了"两个用例（前端独立工具、后端内置流程），一个逻辑源头 (`complete_address_jionlp` 函数）"的核心架构原则，确保了用户预见的补全结果与系统实际使用的结果绝对一致。

---

#### 5. 功能模块四：地名类型后缀管理 (含后台审核)

*   **功能目标**: 此功能旨在通过地址后缀来提升复杂地址的识别率，并建立一个由用户贡献、管理员审核的高质量后缀库，形成良性循环。它包含两个核心部分：
    1.  **用户侧**: 允许用户在地理编码时，临时使用自定义的地址后缀来辅助解析。
    2.  **管理侧**: 将用户实际使用过的后缀作为"候选词"存入数据库，供平台管理员审核，以纳归入官方的、可被自动推荐的后缀库中。

*   **核心模型: "暂存 → 确认 → 审核" 三阶段流程**
    *   **暂存 (Staging)**: 所有用户在界面上的后缀操作（手动添加、删除，系统自动建议）都只在前端的临时列表中进行，不与数据库交互。
    *   **确认 (Confirmation)**: 仅当用户点击任一"编码"按钮时，暂存的后缀列表才会作为参数被"确认"使用，并发送到后端进行持久化记录。
    *   **审核 (Curation)**: 后台记录的后缀都处于"待审核"状态，需要管理员通过后台管理机制（如直接操作数据库）进行筛选和批准，批准后的后缀才能被用于对其他用户进行自动建议。

*   **数据库表结构 (`location_types`表)**
    *   为了支持此模型，`location_types`表需要包含以下字段：
        *   `id`: 主键
        *   `name`: 后缀名称 (TEXT, UNIQUE)
        *   `status`: 状态 (TEXT, 'pending', 'approved', 'rejected')，默认为 'pending'
        *   `source`: 来源 (TEXT, 'user_generated', 'system_default')
        *   `usage_count`: 使用次数 (INTEGER)，默认为 1
        *   `created_at`: 创建时间 (TEXT)
        *   `last_used_at`: 最后使用时间 (TEXT)

*   **执行流程详解**:
    1.  **阶段一：暂存 (前端)**
        *   **手动添加**: 用户在输入框中输入后缀，前端JS将其添加到一个临时的"暂存"数组中，并更新UI。
        *   **系统建议**: 页面加载或地址变化时，前端通过 `/get_location_types` 接口从后端获取**仅包含`status='approved'`**的、高质量的后缀列表。当前端检测到地址结尾与这些已批准的后缀匹配时，会自动将该后缀加入"暂存"数组并更新UI。
        *   **手动移除**: 用户点击标签上的"×"，前端JS将其从"暂存"数组中移除，并更新UI。
        *   *此阶段所有操作均不涉及数据库写入。*

    2.  **阶段二：确认与持久化 (点击编码按钮时)**
        *   用户点击"开始地理编码"或"一键智能编码"。
        *   前端 `geocoding.js` 模块从"暂存"数组中获取最终的后缀列表。
        *   此列表被用于两个地方：
            1.  **用于计算**: 作为参数，随地址列表一同发送给 `/geocode/process` 接口，用于当次的地址解析。
            2.  **用于记录**: **同时**发送给后端的 `/record_used_suffixes` 接口。这是一个"即发即忘"的请求，不阻塞主流程。
    
    3.  **阶段三：后台处理 (Python后端)**
        *   `/record_used_suffixes` 接口接收到后缀列表。
        *   对列表中的每一个后缀，在数据库中执行 `UPSERT` (插入或更新) 逻辑：
            *   **若后缀不存在**: `INSERT` 一条新记录，`status`为`'pending'`, `usage_count`为`1`。
            *   **若后缀已存在**: `UPDATE` 该记录，`usage_count` 加 1，并更新 `last_used_at`。

    4.  **阶段四：管理员审核 (后台管理)**
        *   管理员可定期通过数据库客户端直接执行SQL，对用户贡献的后缀进行管理。
        *   **审核新词**: `SELECT * FROM location_types WHERE status = 'pending';` 然后手动 `UPDATE` 其 `status` 为 `'approved'`。
        *   **清理冷词**: `SELECT * FROM location_types WHERE usage_count < 3;`
        *   **分析热词**: `SELECT * FROM location_types ORDER BY usage_count DESC;`

*   **技术实现概要**:
    *   **HTML**: `index.html` 中，"地名类型"标签应改为"地名类型后缀"。
    *   **前端**: `address-input.js` 和 `address-cleaner.js` 不再调用任何保存接口，只维护一个临时的JS数组。`geocoding.js` 在点击事件中增加一个到 `/record_used_suffixes` 的`fetch`调用。
    *   **后端**: 需要提供一个数据库迁移方案来更新表结构。修改 `/get_location_types` 接口只返回已批准的后缀。新建 `/record_used_suffixes` 接口来实现 `UPSERT` 逻辑。

---

#### 6. 功能模块五：认证与授权策略 (V2.0 定稿)

*   **核心目标**: 建立一个既能鼓励新用户无缝试用，又能保障核心用户付费意愿，同时确保平台资源安全可控的认证与授权体系。

*   **最终方案: "强制登录 + 丰厚新手积分"**
    *   **背景**: 经过对核心客群（地信专业人员、学生）行为模式的分析，我们认识到该群体对"注册"这一操作不敏感，他们更关心工具的专业性和效率。因此，相比于提供有限免费额度的"游客模式"，一个能让他们充分体验所有高级功能的"新手礼包"模式更具吸引力。
    *   **核心策略**:
        1.  **强制登录**: 所有消耗计算资源的功能（包括"普通地理编码"和"一键智能编码"）都必须在用户登录后才能执行。
        2.  **丰厚新手礼包**: 用户首次注册成功后，系统将自动向其账户中赠送一笔可观的初始积分（例如：1000积分）。这笔积分足以让新用户对产品的所有功能（包括高消耗的智能功能）进行充分、深入的测试和评估。
        3.  **统一积分消耗**: 用户登录后，所有编码操作都将统一根据其复杂度和使用的Key类型消耗积分，确保了用户体系内的公平性。

*   **前端交互设计**:
    *   **按钮始终可用**: 页面加载时，无论用户是否登录，"普通地理编码"和"一键智能编码"按钮都保持正常、可点击的状态，不进行灰度禁用处理。
    *   **点击即引导登录**:
        *   当**未登录**用户点击这两个按钮中的任意一个时，系统不会执行编码操作。
        *   取而代之的是，系统会立即调用并显示"登录/注册"模态框，同时可以伴随一个友好的Toast提示，如"请先登录后开始使用"。
    *   **登录后恢复功能**: 用户成功登录后，再次点击编码按钮，将正常触发地理编码的核心业务逻辑。

*   **技术实现概要**:
    *   **后端**:
        *   为所有执行地理编码的API端点（如 `/geocode/process`）增加 `@login_required` 装饰器，从服务端强制执行登录检查。
        *   在用户创建服务（`user_service.py`）中，为新用户直接写入在 `config.py` 中定义的 `NEW_USER_REWARD_POINTS` 初始积分。
    *   **前端 (`script.js`)**:
        *   **移除**所有在页面加载时检查登录状态后，对编码按钮进行 `disabled` 属性切换的逻辑。
        *   在两个编码按钮的 `click` 事件监听器中，保留对 `state.currentUser` 的前置判断。如果用户对象不存在，则直接调用 `showLoginModal()` 函数，并 `return` 终止后续代码执行。

--- 